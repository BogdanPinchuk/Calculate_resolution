function [CWx, CWy] = centerweight2(MTheta, MPhi, MinT, MinP,...
    Nx, Ny, CWx, CWy)
% Функція розрахунку центра мас для пікселів "сусідів" та межі

% Mx, My - масив значень нумерацій точок з врахуванням сусідів
% MTheta, MPhi - лінійні координати точок
% MinT, MinP - масштабні коефіцієнти
% Nx, Ny - кількість точок які можливо відобразити

% % Перерозрахуємо граничні точки
% [MTheta, MPhi] = everyscale(Nx, Ny, MinT, MinP, MTheta, MPhi,...
%     CWx, CWy);

% Необхідно переаналізувати отримані дані, для повторного масштабування
% по іншій із осей
Min0 = min(MinT, MinP);
MinT = MinT / Min0;
MinP = MinP / Min0;

% Приймаючи до уваги те, що за 2-м масштабуванням можливі випадки
% накладання проекцій одна на одну, якщо використовувати аналогічний тип
% визначення центрів мас. Тому в даному випадку щоб уникнути даного
% накладання і перетину необхідно визначити по якому рядку або стовбцю
% найменші відстані між центрами пікселів. Визначивши найкоротший рядок або
% стовбець приймемо його як базовий для центрів мас

% За умови коли КА в надирі, всі відстані між центрами рівні, 
% тому в результаті вибиратиметься крайня точка, в той час як
% має бути центральна, тому необхідно спочатку почати із центральної
% а тоді почати перевіряти всі інші
cenX = round(Nx / 2);
cenY = round(Ny / 2);

% Перевіряємо по якій осі робити вимірювання відстней між центрами крайніх
% піксеілів
if MinT == 1
    % Розраховуємо відстані між точками для центрального значення
    S = vipstanmizpix(MTheta{1}(cenX, 1), MTheta{1}(cenX, Ny),...
        MPhi{1}(cenX, 1), MPhi{1}(cenX, Ny));
    k = cenX;
    
    % Розраховуємо відстані між точками для всіх значень
    for i = 1:Nx
%         if i == 1
%             S = vipstanmizpix(MTheta{1}(i, 1), MTheta{1}(i, Ny),...
%                 MPhi{1}(i, 1), MPhi{1}(i, Ny));
%             k = i;
%         else
            if S > vipstanmizpix(MTheta{1}(i, 1), MTheta{1}(i, Ny),...
                    MPhi{1}(i, 1), MPhi{1}(i, Ny))
                S = vipstanmizpix(MTheta{1}(i, 1), MTheta{1}(i, Ny),...
                    MPhi{1}(i, 1), MPhi{1}(i, Ny));
                k = i;
            end
%         end
    end
else
    % Результат коли MinP == 1
    % Розраховуємо відстані між точками для центрального значення
    S = vipstanmizpix(MTheta{1}(1, cenY), MTheta{1}(Nx, cenY),...
                MPhi{1}(1, cenY), MPhi{1}(Nx, cenY));
    k = cenY;
    
    % Розраховуємо відстані між точками для всіх значень
    for j = 1:Ny
%         if j == 1
%             S = vipstanmizpix(MTheta{1}(1, j), MTheta{1}(Nx, j),...
%                 MPhi{1}(1, j), MPhi{1}(Nx, j));
%             k = j;
%         else
            if S > vipstanmizpix(MTheta{1}(1, j), MTheta{1}(Nx, j),...
                    MPhi{1}(1, j), MPhi{1}(Nx, j))
                S = vipstanmizpix(MTheta{1}(1, j), MTheta{1}(Nx, j),...
                    MPhi{1}(1, j), MPhi{1}(Nx, j));
                k = j;
            end
%         end
    end
end

% Визначаємо min і max границь в циклі
for i = 1:Nx
    for j = 1:Ny
        % Перевіряємо по якій осі робити "сусідство"
        if MinT == 1
            % Записуємо центри мас
            CWx{1}(i, j) = CWx{1}(k, j);
            CWy{1}(i, j) = CWy{1}(k, j);
        else
            % Результат коли MinP == 1
            % Записуємо центри мас
            CWx{1}(i, j) = CWx{1}(i, k);
            CWy{1}(i, j) = CWy{1}(i, k);
        end
    end
end

end
