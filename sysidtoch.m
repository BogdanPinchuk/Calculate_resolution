function Mvih = sysidtoch(Mvh)
% Функція розрахунку сусідніх точок
% тобто розрахунок мінімального сусіда зліва і максимального сусіда справа

% Mvh - вхідний масив (ряд) нумерації точок
% Mvih - вихідний масив нумерації точок
% N - кількість точок

% Розраховуємо кількість точок вх. масиву
N = length(Mvh);

% Корегуємо вихідний масив, вказуючи 1-м числом найменшого сусіда і 2-м
% числом найбільшого сусіда відносно основної точки
for i = 1:N
    % Перевіряємо чи немає "сусідніх" точок лівіше (нижче) від даної
    t = i - 1;
    dt = 1;
    Mvih(1, i) = Mvh(1, i);
    while dt == 1
       % Визначення різниці між номерами пікселів
       if (t >= 1) && (t < N)
           dt = abs((Mvh(i) - Mvh(t)) / (i - t));
       else
           dt = 0;
       end

       % Зміна координат для охоплення "сусідніх" пікселів
       if dt == 1
           % Якщо є сусідній піксель то переписуємо значення
           Mvih(1, i) = Mvh(1, t);
           t = t - 1;
       end
    end
       
    % Перевіряємо чи немає "сусідніх" точок правіше (вище) від даної
    t = i + 1;
    dt = 1;
    Mvih(2, i) = Mvh(1, i);
    while dt == 1
       % Визначення різниці між номерами пікселів
       if (t > 1) && (t <= N)
           dt = abs((Mvh(i) - Mvh(t)) / (i - t));
       else
           dt = 0;
       end

       % Зміна координат для охоплення "сусідніх" пікселів
       if dt == 1
           % Якщо є сусідній піксель то переписуємо значення
           Mvih(2, i) = Mvh(1, t);
           t = t + 1;
       end
    end
    
    % Присвоюємо початкові значення точок аналізу
    Mvih(3, i) = Mvh(1, i);
end

% Конвертуємо нумерацію яка відповідає координатам в нумерацію 
% знаходження масиву
for i = 1:N
    for j = 1:2
        Mvih(j, i) = find(Mvh == Mvih(j, i));
    end
end

end
